#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <stdint.h>

/*
 * ----------FLEXIBLE TELECOMMAND DECODER (FTCD)----------
 *
 *  Authors:    Wouter Doppenberg & David Rijlaarsdam
 *  Date:       07-2019
 *  Course:     AE4S15 Space Embedded Systems - TU Delft
 *  Instructor: Alessandra Menicucci
 *
 * -------------------------------------------------------
 */

#define MSG_TYPE uint8_t    // Data type for packets, not all datatypes are possible!
#define TYPE_MAX UINT8_MAX  // Maximum attainable value for MSG_TYPE
#define MSG_SIZE 223       // Placeholder, the message size needs to be dynamic in the future.

// CUSTOM HEADERS
#include "rs.h"
#include "encoder.h"
#include "decoder.h"


int write_to_file(int count, MSG_TYPE write[], char const *fileName)
{
    FILE *f = fopen(fileName, "w");
    if (f == NULL) return -1;
    while (count-- > 0) {
        // you might want to check for out-of-disk-space here, too
        fprintf(f, "%i\n", *write);
        ++write;
    }
    fclose(f);
    return 0;
}

int main()
{

    register int i; // register merely tells the compiler to prioritize this variable in the register
    MSG_TYPE msg_send[MSG_SIZE];

    /*
     * Generate lookup tables needed for Reed Solomon encoding / decoding.
     * Additional information along with the parameters for encoding / decoding
     * are provided in rs.h.
     *
     * Functions generate_gf(), gen_poly(), encode_rs(), and decode_rs() courtesy
     * of Simon Rockliff, University of Adelaide. Some adjustments have been made
     * in order for them to work within the framework built for this project.
     *
     * Note: If this software is split up between 2 devices, they should both
     * have the same global variables (from rs.h), and need generate_gf() +
     * gen_poly() to have been called just once during system boot.
     */

    generate_gf(); gen_poly();

    // Fill msg_send with something...
    for ( i = 0; i < MSG_SIZE; i++ )
    {
        msg_send[i] = i%TYPE_MAX;
    }

    /*
     * Generate transfer frame, which contains a pointer to the array of
     * packets, and the size of that array.
     *
     * The data is split according to the size of each packet:
     * Total size 255 bytes + 5 header;
     * 255 = 223 data + 32 Error correction.
     *
     * Error correction field(s) will be filled with the parity bits
     * generated by the Reed Solomon code.
     */

    transfer_t transfer = gen_transfer(msg_send, MSG_SIZE);

    printf("ORIGINAL MESSAGE\n");
    print_transfer(&transfer);
    //write_to_file(MSG_SIZE, transfer.packs[0].data, "ORIGINAL_MESSAGE.csv");

    /*
     * Transfer between devices should happen between here ->
     */

    // Corrupt some data - up to tt bytes can be corrected
    for (i = 50; i < tt+50; i++)
        transfer.packs[0].data[i] = 111;

    printf("CORRUPTED MESSAGE\n");
    print_transfer(&transfer);
    //write_to_file(MSG_SIZE, transfer.packs[0].data, "CORRUPTED_MESSAGE.csv");

    /*
     * And here.
     */

    decode_transfer(&transfer); // Redundant: this is done in unpack_transfer too

    printf("DECODED MESSAGE\n");
    print_transfer(&transfer);
    //write_to_file(MSG_SIZE, transfer.packs[0].data, "DECODED_MESSAGE.csv");

    MSG_TYPE * msg_recv = unpack_transfer(&transfer);

    // Print data for check
    //printf("i \t\t msg_send[i] \t\t msg_recv[i]\n");
    //for (i = 0; i < MSG_SIZE; i++) printf("%3d \t\t %-11d \t\t %-11d\n", i, msg_send[i], msg_recv[i]);

    // Free memory - PAY ATTENTION TO THIS WHEN PORTING TO AN EMBEDDED CHIP
    free(msg_recv);
    free(transfer.packs);

    printf("sizeof(packet_t)   = %d\n", (int)sizeof(packet_t));
    printf("sizeof(transfer_t)   = %d\n", (int)sizeof(transfer_t));

    /*
     * Pointers have been used wherever possible, however do realize that a pointer on
     * 32-bit memory such as the ARM M0+ takes up 32/8 = 4 bytes(!), whereas a single
     * bytes (e.g. uint8_t) obviously only occupies 1 byte. Pointers do have the advantage
     * of speed, so a trade-off should be done for this system.
     *
     * Implementing static memory allocation could possibly alleviate this issue.
     */

    return 0;
}